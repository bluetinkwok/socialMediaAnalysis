"""
Malware scanning module for the Social Media Analysis Platform.

This module provides functionality to scan files for malware using ClamAV
and other security checks.
"""

import os
import logging
import tempfile
import asyncio
import clamd
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union, BinaryIO
from fastapi import UploadFile, HTTPException, status

from core.config import get_settings

# Configure logging
logger = logging.getLogger(__name__)
settings = get_settings()

class MalwareScanner:
    """
    Provides malware scanning capabilities using ClamAV and other methods.
    """
    
    def __init__(self, host: str = None, port: int = None):
        """
        Initialize the malware scanner.
        
        Args:
            host: ClamAV host (default: from settings)
            port: ClamAV port (default: from settings)
        """
        self.host = host or settings.clamav_host
        self.port = port or settings.clamav_port
        self._clamd = None
        
    @property
    def clamd(self):
        """Get or initialize the ClamAV daemon connection."""
        if self._clamd is None:
            try:
                # Try to connect to ClamAV daemon
                self._clamd = clamd.ClamdNetworkSocket(
                    host=self.host,
                    port=self.port
                )
                # Test the connection
                self._clamd.ping()
                logger.info(f"Connected to ClamAV daemon at {self.host}:{self.port}")
            except (clamd.ConnectionError, AttributeError) as e:
                logger.warning(f"Failed to connect to ClamAV daemon: {str(e)}")
                # Fall back to Unix socket if network socket fails
                try:
                    self._clamd = clamd.ClamdUnixSocket()
                    self._clamd.ping()
                    logger.info("Connected to ClamAV daemon via Unix socket")
                except (clamd.ConnectionError, AttributeError) as e:
                    logger.error(f"Failed to connect to ClamAV daemon via Unix socket: {str(e)}")
                    self._clamd = None
        
        return self._clamd
    
    async def scan_file(self, file_path: Union[str, Path]) -> Tuple[bool, Optional[str]]:
        """
        Scan a file for malware using ClamAV.
        
        Args:
            file_path: Path to the file to scan
            
        Returns:
            Tuple of (is_clean, threat_found)
        """
        if not self.clamd:
            logger.warning("ClamAV daemon not available, skipping scan")
            return True, None
        
        try:
            # Convert to string if Path object
            file_path_str = str(file_path)
            
            # Scan the file
            scan_result = self.clamd.scan(file_path_str)
            
            # Parse the scan result
            file_result = scan_result.get(file_path_str)
            if file_result:
                status, virus_name = file_result
                
                if status == "FOUND":
                    logger.warning(f"Malware found in {file_path_str}: {virus_name}")
                    return False, virus_name
            
            # If no result or status is "OK", the file is clean
            return True, None
            
        except Exception as e:
            logger.error(f"Error scanning file {file_path}: {str(e)}")
            # Return clean with a warning if scanning fails
            return True, f"Scan error: {str(e)}"
    
    async def scan_file_stream(self, file_content: bytes) -> Tuple[bool, Optional[str]]:
        """
        Scan file content for malware using ClamAV.
        
        Args:
            file_content: Binary content of the file
            
        Returns:
            Tuple of (is_clean, threat_found)
        """
        if not self.clamd:
            logger.warning("ClamAV daemon not available, skipping scan")
            return True, None
        
        try:
            # Create a temporary file
            with tempfile.NamedTemporaryFile(delete=False) as temp_file:
                temp_file.write(file_content)
                temp_file_path = temp_file.name
            
            try:
                # Scan the temporary file
                return await self.scan_file(temp_file_path)
            finally:
                # Clean up the temporary file
                os.unlink(temp_file_path)
                
        except Exception as e:
            logger.error(f"Error scanning file stream: {str(e)}")
            # Return clean with a warning if scanning fails
            return True, f"Scan error: {str(e)}"
    
    async def scan_upload_file(self, upload_file: UploadFile) -> Tuple[bool, Optional[str]]:
        """
        Scan an uploaded file for malware using ClamAV.
        
        Args:
            upload_file: The uploaded file
            
        Returns:
            Tuple of (is_clean, threat_found)
        """
        if not self.clamd:
            logger.warning("ClamAV daemon not available, skipping scan")
            return True, None
        
        try:
            # Read the file content
            content = await upload_file.read()
            
            # Reset the file position for future reads
            await upload_file.seek(0)
            
            # Scan the file content
            return await self.scan_file_stream(content)
            
        except Exception as e:
            logger.error(f"Error scanning uploaded file {upload_file.filename}: {str(e)}")
            # Return clean with a warning if scanning fails
            return True, f"Scan error: {str(e)}"
    
    async def get_clamav_version(self) -> Optional[str]:
        """
        Get the ClamAV version.
        
        Returns:
            ClamAV version string or None if not available
        """
        if not self.clamd:
            return None
        
        try:
            version = self.clamd.version()
            return str(version)
        except Exception as e:
            logger.error(f"Error getting ClamAV version: {str(e)}")
            return None
    
    async def get_clamav_status(self) -> Dict[str, Union[bool, str, None]]:
        """
        Get the status of the ClamAV connection.
        
        Returns:
            Dictionary with status information
        """
        status = {
            "available": False,
            "version": None,
            "error": None
        }
        
        try:
            if self.clamd:
                version = await self.get_clamav_version()
                if version:
                    status["available"] = True
                    status["version"] = version
                else:
                    status["error"] = "Could not retrieve ClamAV version"
            else:
                status["error"] = "ClamAV daemon not available"
        except Exception as e:
            status["error"] = str(e)
            
        return status


# Create a global instance of the malware scanner
malware_scanner = MalwareScanner() 