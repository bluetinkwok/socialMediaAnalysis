"""
Tests for the malware scanner module.
"""
import os
import io
import pytest
from unittest.mock import patch, MagicMock
from pathlib import Path
from fastapi import UploadFile

from core.malware_scanner import MalwareScanner

# EICAR test string - a standard test file for anti-virus software
# This is a harmless file that anti-virus software should detect as malware
EICAR_TEST_STRING = (
    b'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*'
)

@pytest.fixture
def malware_scanner():
    """Create a MalwareScanner instance for testing."""
    return MalwareScanner(host="localhost", port=3310)

@pytest.fixture
def mock_clamd():
    """Mock the ClamAV daemon."""
    with patch('clamd.ClamdNetworkSocket') as mock_clamd_network:
        # Configure the mock
        mock_instance = MagicMock()
        mock_clamd_network.return_value = mock_instance
        
        # Configure ping method
        mock_instance.ping.return_value = True
        
        # Configure version method
        mock_instance.version.return_value = "ClamAV 0.103.5"
        
        yield mock_instance

@pytest.fixture
def mock_clamd_with_virus():
    """Mock the ClamAV daemon that finds a virus."""
    with patch('clamd.ClamdNetworkSocket') as mock_clamd_network:
        # Configure the mock
        mock_instance = MagicMock()
        mock_clamd_network.return_value = mock_instance
        
        # Configure ping method
        mock_instance.ping.return_value = True
        
        # Configure version method
        mock_instance.version.return_value = "ClamAV 0.103.5"
        
        # Configure scan method to return a virus
        mock_instance.scan.return_value = {
            "/path/to/file": ("FOUND", "EICAR-Test-Signature")
        }
        
        yield mock_instance

@pytest.fixture
def mock_clamd_connection_error():
    """Mock the ClamAV daemon with connection error."""
    with patch('clamd.ClamdNetworkSocket') as mock_clamd_network:
        # Configure the mock to raise an exception
        mock_clamd_network.side_effect = Exception("Connection refused")
        
        # Also mock the Unix socket as a fallback
        with patch('clamd.ClamdUnixSocket') as mock_clamd_unix:
            mock_clamd_unix.side_effect = Exception("Socket not found")
            
            yield mock_clamd_network

@pytest.fixture
def test_upload_file():
    """Create a test upload file."""
    file_content = b"This is a test file content"
    file = io.BytesIO(file_content)
    
    # Create an UploadFile with async methods
    upload_file = UploadFile(
        filename="test.txt",
        file=file,
    )
    
    # Replace methods with async versions
    async def async_read():
        return file.getvalue()
        
    async def async_seek(position):
        file.seek(position)
        
    upload_file.read = async_read
    upload_file.seek = async_seek
    
    return upload_file

@pytest.fixture
def test_virus_upload_file():
    """Create a test upload file with EICAR test string."""
    file = io.BytesIO(EICAR_TEST_STRING)
    
    # Create an UploadFile with async methods
    upload_file = UploadFile(
        filename="eicar.txt",
        file=file,
    )
    
    # Replace methods with async versions
    async def async_read():
        return file.getvalue()
        
    async def async_seek(position):
        file.seek(position)
        
    upload_file.read = async_read
    upload_file.seek = async_seek
    
    return upload_file

@pytest.mark.asyncio
async def test_scanner_initialization():
    """Test scanner initialization with default values."""
    scanner = MalwareScanner()
    assert scanner.host == "localhost"  # Default from settings
    assert scanner.port == 3310  # Default from settings
    
    # Test with custom values
    scanner = MalwareScanner(host="custom-host", port=1234)
    assert scanner.host == "custom-host"
    assert scanner.port == 1234

@pytest.mark.asyncio
async def test_clamd_connection(mock_clamd, malware_scanner):
    """Test ClamAV daemon connection."""
    # Access the clamd property to trigger connection
    clamd_instance = malware_scanner.clamd
    
    # Verify the connection was established
    assert clamd_instance is not None
    mock_clamd.ping.assert_called_once()

@pytest.mark.asyncio
async def test_clamd_connection_error(mock_clamd_connection_error):
    """Test ClamAV daemon connection error handling."""
    scanner = MalwareScanner()
    
    # Access the clamd property to trigger connection attempt
    clamd_instance = scanner.clamd
    
    # Verify connection failed
    assert clamd_instance is None

@pytest.mark.asyncio
async def test_scan_file_clean(mock_clamd, malware_scanner, tmp_path):
    """Test scanning a clean file."""
    # Create a test file
    test_file = tmp_path / "clean.txt"
    test_file.write_text("This is a clean file")
    
    # Configure the mock to return a clean result
    mock_clamd.scan.return_value = {
        str(test_file): ("OK", None)
    }
    
    # Scan the file
    is_clean, threat = await malware_scanner.scan_file(test_file)
    
    # Verify the result
    assert is_clean is True
    assert threat is None
    mock_clamd.scan.assert_called_once_with(str(test_file))

@pytest.mark.asyncio
async def test_scan_file_infected(mock_clamd_with_virus, malware_scanner, tmp_path):
    """Test scanning an infected file."""
    # Create a test file
    test_file = tmp_path / "infected.txt"
    test_file.write_bytes(EICAR_TEST_STRING)
    
    # Scan the file
    is_clean, threat = await malware_scanner.scan_file(test_file)
    
    # Verify the result
    assert is_clean is False
    assert threat == "EICAR-Test-Signature"
    mock_clamd_with_virus.scan.assert_called_once_with(str(test_file))

@pytest.mark.asyncio
async def test_scan_file_stream_clean(mock_clamd, malware_scanner):
    """Test scanning a clean file stream."""
    # Configure the mock to return a clean result
    mock_clamd.scan.return_value = {
        mock_clamd.scan.call_args[0][0]: ("OK", None)
    }
    
    # Scan the file stream
    is_clean, threat = await malware_scanner.scan_file_stream(b"This is a clean file")
    
    # Verify the result
    assert is_clean is True
    assert threat is None
    assert mock_clamd.scan.called

@pytest.mark.asyncio
async def test_scan_file_stream_infected(mock_clamd_with_virus, malware_scanner):
    """Test scanning an infected file stream."""
    # Scan the file stream
    is_clean, threat = await malware_scanner.scan_file_stream(EICAR_TEST_STRING)
    
    # Verify the result
    assert is_clean is False
    assert threat == "EICAR-Test-Signature"
    assert mock_clamd_with_virus.scan.called

@pytest.mark.asyncio
async def test_scan_upload_file_clean(mock_clamd, malware_scanner, test_upload_file):
    """Test scanning a clean upload file."""
    # Configure the mock to return a clean result
    mock_clamd.scan.return_value = {
        mock_clamd.scan.call_args[0][0] if mock_clamd.scan.called else "": ("OK", None)
    }
    
    # Scan the upload file
    is_clean, threat = await malware_scanner.scan_upload_file(test_upload_file)
    
    # Verify the result
    assert is_clean is True
    assert threat is None
    assert mock_clamd.scan.called

@pytest.mark.asyncio
async def test_scan_upload_file_infected(mock_clamd_with_virus, malware_scanner, test_virus_upload_file):
    """Test scanning an infected upload file."""
    # Scan the upload file
    is_clean, threat = await malware_scanner.scan_upload_file(test_virus_upload_file)
    
    # Verify the result
    assert is_clean is False
    assert threat == "EICAR-Test-Signature"
    assert mock_clamd_with_virus.scan.called

@pytest.mark.asyncio
async def test_get_clamav_version(mock_clamd, malware_scanner):
    """Test getting the ClamAV version."""
    # Get the version
    version = await malware_scanner.get_clamav_version()
    
    # Verify the result
    assert version == "ClamAV 0.103.5"
    mock_clamd.version.assert_called_once()

@pytest.mark.asyncio
async def test_get_clamav_status_available(mock_clamd, malware_scanner):
    """Test getting the ClamAV status when available."""
    # Get the status
    status = await malware_scanner.get_clamav_status()
    
    # Verify the result
    assert status["available"] is True
    assert status["version"] == "ClamAV 0.103.5"
    assert status["error"] is None

@pytest.mark.asyncio
async def test_get_clamav_status_unavailable(mock_clamd_connection_error):
    """Test getting the ClamAV status when unavailable."""
    scanner = MalwareScanner()
    
    # Get the status
    status = await scanner.get_clamav_status()
    
    # Verify the result
    assert status["available"] is False
    assert status["version"] is None
    assert status["error"] == "ClamAV daemon not available" 